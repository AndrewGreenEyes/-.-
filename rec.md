# Рекурсия
Рекурсия - это функция которая вызывает сама себя. Рекурсия в памяти напоминает стек.
Например с помощью рекурсии можно перебрать перестановки:

*Коментарий:перестановка это список чисел у которого есть все числа от 1 до N в произвольном порядке.*

Исходный код для перебора перестановок:

```python
def f(num=[], s=1):
    if len(num) == s:
        print(*num)
        return
    for i in range(1, s+1):
        if i in num:continue
        num.append(i)
        f(num, s)
        num.pop()
f([], 3)
```

*Разбор программы*

1. Если мы добавлили какой-то объект в список то потом должны его убрать.
2. Если мы сгенирировали перестановку то нужно выйти из рекурсии.


Также перестановки могут быть с ограничениями. Например, задача:

##### Нетроичные перестановки
Теперь нужно сгенирировать те жесамые перестановки но чтобы никакие 2 соседних числа не делились на 5.

*Коментарий: теперь нужно добавить в цикле `for` добавить условие.*

```python
def f(num=[], s=1):
    if len(num) == s:
        print(*num)
        return
    for i in range(1, s+1):
        if i in num:continue
        if len(num) > 0 and (num[-1] + i) % 5 == 0:continue
        num.append(i)
        f(num, s)
        num.pop()
f([], 3)
```

------

## Многофункциональная рекурсия

Здесь рассмотрим рекурсию у которой больше 1-ой рекурсивной функции.

[#сириус](https://sirius.ru)

**Фишки**

Дана полоска из клеток, пронумерованных от 1 до N слева направо. 
Разрешено делать такие действия:

+ Снимать или ставить фишку на клетку с номером 1.
+ Ставить фишку на клетку, следующую за самой левой из установленных фишек (правее неё), если она пуста.

+ Удалять самую левою фишку

Изначально полоска пуста. Нужно разместить фишки во всех клетках.


*Решение*.

Что бы поставитть 3 фишки нам понадобится такие операции:

1. Ставим фишку 1
2. Ставим фишку 2
3. Удаляем 1-фишку
4. Ставим фишку 3
5. Ставим фишку 1

Я эту задачу решил написав 2 рекурсивных функции.

```python
n = int(input())
def setf(v, operations=[]):
    if v == 1:
        return [1]
    elif v == 2:
        return [1, 2]
    else:
        t = setf(v-1)
        t2 = delf(v-2)
        t3 = setf(v-2)
        t4 = t + t2 + [v] + t3
        return t4

def delf(v, operations=[]):
    if v == 1:
        return [-1]
    elif v == 2:
        return [-2, -1]
    else:
        t = setf(v)[::-1]
        for i in range(len(t)):
            t[i] = -t[i]
        return t

s = setf(n)
print(*s)
```

##### Автомобильные номера

Подсказки

Решение этой задачи состоит из 3 функций:

1. Функция которая генерит 1 букву номера
2. Функция которая генерирует 3 цифры номера
3. Функция которая генерирует 2 буквы номера
